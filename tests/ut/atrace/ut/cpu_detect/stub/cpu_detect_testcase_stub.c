/**
 * Copyright (c) 2025 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */
#include <stdint.h>

// Taishan
void TaishanFpComparisonP01(uint32_t *reg_values)
{
    return;
}

void TaishanFpMiniMaxiP01(uint32_t *reg_values)
{
    return;
}

void TaishanFpMovMaddP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdAddP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdAritheticP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdCompareP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdComplexP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdCryptoP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdElementArithemticP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdFpIntConversionP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdImmP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdMovP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdPairArithmeticP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdPermuteP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdReduceP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdUnaryArithmeticP01(uint32_t *reg_values)
{
    return;
}

void TaishanSimdWideNarryArthemticP01(uint32_t *reg_values)
{
    return;
}

void TaishanIntAluP01(uint32_t *reg_values)
{
    return;
}

void TaishanIntCcP01(uint32_t *reg_values)
{
    return;
}

void TaishanIntMduP01(uint32_t *reg_values)
{
    return;
}

void TaishanIntAluP02(uint32_t *reg_values)
{
    return;
}

void TaishanIntMduP02(uint32_t *reg_values)
{
    return;
}

void TaishanIntCacheWriteReadP01(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void TaishanIntCacheWriteReadP02(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void TaishanIntCacheWriteReadP03(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void TaishanIntCacheWriteReadP04(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void TaishanIntCacheWriteReadP05(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void TaishanIntCacheWriteReadP06(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

// GroupA
void SinglePressAdvsimdScalar01(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdScalar02(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdScalar03(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdVector01(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdVector02(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdVector03(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdVector04(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdVector05(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdVector06(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdVector07(uint32_t *reg_values)
{
    return;
}

void SinglePressAdvsimdVector08(uint32_t *reg_values)
{
    return;
}

void SinglePressFloat01(uint32_t *reg_values)
{
    return;
}

void SinglePressFloat02(uint32_t *reg_values)
{
    return;
}

void SinglePressFloat03(uint32_t *reg_values)
{
    return;
}

void SinglePressInt01(uint32_t *reg_values)
{
    return;
}

void SinglePressInt02(uint32_t *reg_values)
{
    return;
}

void SinglePressInt03(uint32_t *reg_values)
{
    return;
}

// GroupB
void TSRTIntAllOperation(uint32_t *reg_values)
{
    return;
}

void TSRTIntCompare(uint32_t *reg_values)
{
    return;
}

void TSRTIntAlu(uint32_t *reg_values)
{
    return;
}

void TSRTIntCRCAndShiftAndMov(uint32_t *reg_values)
{
    return;
}

// GroupC
void TSRTFloatAllOperation(uint32_t *reg_values)
{
    return;
}

void TSRTFloatCompare(uint32_t *reg_values)
{
    return;
}

void TSRTFloatFixedPointConvertToFloatPoint(uint32_t *reg_values)
{
    return;
}

void TSRTFloatFloatPointConvertPrecision(uint32_t *reg_values)
{
    return;
}

void TSRTFloatFloatPointRoundToInteger(uint32_t *reg_values)
{
    return;
}

void TSRTFloatMinMax(uint32_t *reg_values)
{
    return;
}

void TSRTFloatMovMadd(uint32_t *reg_values)
{
    return;
}

// GroupD
void TSRTAdvsimdScalarAllOperation(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdScalarCompare(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdScalarFixedPointConvertToFloatPoint(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdScalarFloatPointConvertToInteger(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdScalarGeneralOperation(uint32_t *reg_values)
{
    return;
}

// GroupE
void TSRTAdvsimdVectorAllOperation(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdVectorCompare(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdVectorFixedPointConvertToFloatingPoint(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdVectorFloatingPointConvertToInteger(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdVectorFloatingPointOperation(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdVectorGeneralOperation(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdVectorMaxMin(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdVectorSecureHashStandard(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdVectorSignedOperation(uint32_t *reg_values)
{
    return;
}

void TSRTAdvsimdVectorUnsignedOperation(uint32_t *reg_values)
{
    return;
}

// GroupF
void AdvsimdLoadDeprecatedP01(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadDeprecatedP02(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadDeprecatedP03(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadDeprecatedP04(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadStoreP01(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadStoreP02(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadStoreP03(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadStoreP04(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadStoreP05(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadStoreP06(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void AdvsimdLoadStoreP07(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void FpsimdLoadStoreP01(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void FpsimdLoadStoreP02(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void GeneralLoadStoreP01(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void GeneralLoadStoreP02(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void GeneralLoadStoreP03(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void GeneralLoadStoreP04(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

// GroupG
void BranchInGeneralP01(uint32_t *reg_values)
{
    return;
}

void BranchInGeneralP02(uint32_t *reg_values)
{
    return;
}

// GroupH
void DataReverseAdvsimdScalarP01(uint32_t *reg_values)
{
    return;
}

void DataReverseAdvsimdVectorP01(uint32_t *reg_values)
{
    return;
}

void DataReverseAdvsimdVectorP02(uint32_t *reg_values)
{
    return;
}

void DataReverseAdvsimdVectorP03(uint32_t *reg_values)
{
    return;
}

void DataReverseAdvsimdVectorP04(uint32_t *reg_values)
{
    return;
}

void DataReverseFloatP01(uint32_t *reg_values)
{
    return;
}

void DataReverseIntP01(uint32_t *reg_values)
{
    return;
}

void EnhanceBranchP01(uint32_t *reg_values)
{
    return;
}

void EnhanceDependencyP01(uint32_t *reg_values)
{
    return;
}

void EnhanceLoadStoreP01(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}

void EnhanceLoadStoreP02(uint32_t *reg_values, uint32_t *load_store_buf)
{
    return;
}
