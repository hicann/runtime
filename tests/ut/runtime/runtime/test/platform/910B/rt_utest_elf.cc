/**
 * Copyright (c) 2025 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */
#include "driver/ascend_hal.h"
#include "runtime/rt.h"
#include "runtime.hpp"
#define private public
#include "kernel.hpp"
#include "program.hpp"
#undef private
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include "securec.h"
#include <thread>
#include <unistd.h>
#include "device.hpp"
#include "gtest/gtest.h"
#include "mockcpp/mockcpp.hpp"
#include "thread_local_container.hpp"

#include "elf.hpp"

using namespace testing;
using namespace cce::runtime;

class CloudV2ELFTest : public testing::Test
{
protected:
    static void SetUpTestCase()
    {
        std::cout<<"ELF test start"<<std::endl;

    }

    static void TearDownTestCase()
    {
        std::cout<<"ELF test start end"<<std::endl;

    }

    // Some expensive resource shared by all tests.
    virtual void SetUp()
    {
        rtSetDevice(0);
        std::cout << "a test SetUP" << std::endl;
        rtError_t error;
        Runtime *rtInstance = const_cast<Runtime *>(Runtime::Instance());
        EXPECT_NE(rtInstance, nullptr);
        GlobalContainer::SetHardwareChipType(CHIP_END);
		GlobalMockObject::verify();
    }
    virtual void TearDown()
    {
        rtDeviceReset(0);
        std::cout << "a test TearDown" << std::endl;
        Runtime *rtInstance = const_cast<Runtime *>(Runtime::Instance());
        EXPECT_NE(rtInstance, nullptr);
		GlobalMockObject::verify();
    }
private:
    rtChipType_t originType;
};


TEST_F(CloudV2ELFTest, ELF_CONVERT_TASK_RATION_ERROR)
{
unsigned char static_kernel_data[] = {
    0x7f,0x45,0x4c,0x46,0x2,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x29,0x10,
    0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x20,0x12,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x93,0x0,0x40,0x0,0x38,0x0,0x2,0x0,0x40,0x0,
    0x9,0x0,0x7,0x0,0x1,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0xb0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14,0xb,0x0,0x0,
    0x0,0x0,0x0,0x0,0x14,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x51,0xe5,0x74,0x64,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x7,
    0x80,0x38,0x9e,0x2,0x10,0x0,0x61,0x7,0x81,0x7,0x21,0x0,0x80,0x8,0x1f,0x2,0xff,0x7f,0x22,0x7,
    0x8a,0xf8,0xde,0x0,0x0,0x80,0x22,0x7,0x1,0x0,0x0,0x7,0x84,0xf8,0x20,0x0,0x80,0x0,0x0,0x2,
    0x0,0x0,0x40,0x80,0xc0,0x7f,0x3a,0x7,0x80,0x0,0x40,0x80,0x10,0x0,0x7b,0x7,0x80,0x38,0x9e,0x2,
    0x0,0x9,0x11,0x2,0x81,0xd7,0x3b,0x0,0x80,0x8,0x1f,0x2,0xff,0x7f,0x20,0x7,0xa,0xf8,0xde,0x0,
    0x0,0x80,0x22,0x7,0x84,0xf8,0x3a,0x0,0x58,0xd1,0x3d,0x8,0x80,0x48,0x0,0x2,0x80,0x88,0xa,0x2,
    0xa0,0x0,0xc4,0x9,0x0,0x50,0xc,0x8,0x80,0x1,0xc8,0x9,0x0,0x60,0xc2,0x4,0x80,0x38,0x0,0x2,
    0x6,0x0,0x2,0x7,0x0,0x14,0xc0,0x2,0x7,0x0,0x2,0x7,0x0,0x14,0xc0,0x2,0x8,0x0,0xc,0x7,
    0x0,0x64,0xc0,0x2,0x0,0x9,0x6,0x2,0x80,0xff,0xe,0x7,0x80,0x38,0x2,0x2,0x38,0x0,0x0,0x7,
    0x7,0x0,0x4f,0x7,0x0,0x4,0xc2,0x2,0x0,0x19,0x6,0x2,0x28,0xed,0x8f,0x4,0x0,0x0,0x2,0x7,
    0x0,0x0,0xe,0x7,0x20,0xe7,0x91,0x8,0x80,0xe5,0x35,0xf,0x81,0x83,0xc2,0x9,0x0,0x0,0x2,0x7,
    0x0,0x0,0xe,0x7,0x10,0xe7,0x91,0x8,0x0,0x5,0x12,0x7,0x81,0x83,0xc2,0x9,0x0,0x0,0x2,0x7,
    0x0,0x0,0xe,0x7,0x88,0xe7,0x91,0x8,0xff,0xff,0x53,0x7,0x81,0x83,0xc2,0x9,0x0,0x0,0x2,0x7,
    0x0,0x0,0xe,0x7,0x78,0xe7,0x91,0x8,0x81,0x83,0xc2,0x9,0x0,0x0,0x2,0x7,0x0,0x0,0xe,0x7,
    0x68,0xe7,0x91,0x8,0x81,0x83,0xc2,0x9,0x0,0x0,0x2,0x7,0x0,0x0,0xe,0x7,0x58,0xe7,0x91,0x8,
    0x81,0x83,0xc2,0x9,0x0,0x0,0x2,0x7,0x0,0x0,0xe,0x7,0x48,0xe7,0x91,0x8,0x81,0x83,0xc2,0x9,
    0x0,0x0,0x2,0x7,0x0,0x0,0xe,0x7,0x38,0xe7,0x91,0x8,0x81,0x83,0xc2,0x9,0x80,0x98,0xe,0x2,
    0x0,0x40,0x10,0x7,0x85,0x83,0xe,0x0,0x8,0x50,0x2,0x8,0x88,0x7,0xa,0x7,0x82,0xe2,0xb,0x0,
    0x68,0xe1,0x91,0x8,0x0,0x10,0xca,0x4,0x0,0x7a,0x8a,0x2,0x0,0xeb,0xe3,0xf,0x2,0xe0,0xb5,0xf,
    0x2,0xe1,0xb5,0xf,0x82,0xe0,0xb5,0xf,0xa0,0xe5,0x35,0xf,0x0,0xe6,0x35,0xf,0x0,0xea,0x35,0xf,
    0x0,0xee,0x35,0xf,0x1,0x83,0x8e,0x9,0x0,0x58,0xe,0x2,0x84,0x2,0x4e,0x2,0x80,0x18,0xc,0x2,
    0xa0,0xee,0x8f,0x4,0x80,0xf8,0x8f,0x2,0x3,0x73,0xe,0x0,0x80,0x8,0xd0,0x2,0x1,0x74,0xe,0x0,
    0x83,0x72,0xa,0x0,0x98,0xee,0x8f,0x3,0x1,0x2,0xca,0x2,0x81,0x42,0x8,0x0,0xe0,0xed,0xc9,0x4,
    0x90,0xed,0xcf,0x4,0x80,0xf8,0x89,0x2,0x3,0x43,0x8,0x0,0x80,0x8,0xca,0x2,0x81,0x42,0x8,0x0,
    0x83,0x43,0x8,0x0,0x98,0xee,0x8b,0x3,0x1,0x2,0xc8,0x2,0x1,0x32,0x6,0x0,0x38,0xee,0xc7,0x4,
    0xe8,0xed,0xcb,0x4,0x80,0xf8,0x87,0x2,0x3,0x33,0x6,0x0,0x80,0x8,0xc8,0x2,0x0,0x7,0xc,0x7,
    0x1,0x32,0x6,0x0,0x83,0x32,0x6,0x0,0x98,0xee,0x89,0x3,0x2,0xe3,0xd,0x0,0x1,0x2,0xc6,0x2,
    0x81,0x21,0x4,0x0,0x2,0x0,0x6,0x7,0x90,0xee,0xc5,0x4,0x40,0xee,0xc9,0x4,0xa0,0xee,0x89,0x3,
    0x30,0xed,0xc7,0x4,0x2c,0xed,0xb,0x3,0x1,0x2,0xc8,0x2,0x1,0x0,0x4,0x7,0x0,0x58,0xe,0x2,
    0x4,0x2,0xce,0x2,0x81,0x63,0xe,0x0,0x0,0x78,0x14,0x2,0x48,0xed,0xcf,0x4,0xe4,0xe8,0x91,0x3,
    0x40,0x34,0xd4,0x2,0x0,0x70,0x92,0x4,0x80,0x20,0x4,0x2,0x0,0xa0,0x90,0x4,0x1,0x82,0x10,0x0,
    0x8,0x70,0x88,0x4,0x82,0x71,0x80,0xf,0x21,0x74,0x92,0x9,0x18,0x70,0x88,0x4,0x82,0x73,0x80,0xf,
    0x1,0x82,0xe,0x0,0x2,0x50,0x10,0x8,0x0,0x8a,0x10,0x2,0x4,0x2,0xd0,0x2,0x1,0x64,0x10,0x0,
    0x0,0x88,0x14,0x2,0x40,0x34,0xd4,0x2,0x50,0xed,0xc7,0x4,0x68,0xed,0xd1,0x4,0x0,0x80,0x92,0x4,
    0x0,0xa0,0x8e,0x4,0x1,0x72,0xe,0x0,0x8,0x80,0x88,0x4,0x82,0x81,0x80,0xf,0xa1,0x83,0x92,0x9,
    0x18,0x80,0x88,0x4,0x82,0x83,0x80,0xf,0x4,0x50,0x10,0x8,0x0,0x8a,0x10,0x2,0x4,0x2,0xd0,0x2,
    0x1,0x64,0xc,0x0,0x1,0x72,0xe,0x0,0x0,0x6,0x10,0x7,0x0,0x68,0x12,0x2,0x70,0xed,0xc7,0x4,
    0xff,0xff,0x51,0x7,0x40,0x34,0xd2,0x2,0x1,0x72,0x6,0x0,0x88,0xed,0xcd,0x4,0x0,0x60,0x90,0x4,
    0x0,0x90,0x8e,0x4,0x8,0x60,0x88,0x4,0x82,0x61,0x80,0xf,0xa1,0x61,0x90,0x9,0x18,0x60,0x88,0x4,
    0x1,0x32,0x6,0x0,0x6,0x50,0x8,0x8,0x82,0x63,0x80,0xf,0xe4,0xe8,0x87,0x4,0x2c,0xed,0x9,0x4,
    0x9c,0xee,0x87,0x3,0x1,0x0,0x8,0x7,0x88,0x0,0x40,0x80,0x1,0x2,0xc6,0x2,0x80,0x39,0x86,0x2,
    0x2e,0x32,0x0,0x0,0x8,0x0,0x40,0x80,0x4c,0x1,0x20,0x40,0x1,0x1,0x16,0x7,0xd0,0x2,0x14,0x7,
    0x90,0x2,0x18,0x7,0x0,0x0,0x10,0x7,0x1,0x8,0x57,0x7,0x2,0xe5,0x15,0x0,0xb0,0x2,0xa,0x7,
    0x2,0xe6,0x19,0x0,0x1,0x0,0x51,0x7,0x8,0x8,0x97,0x7,0x82,0xe2,0xb,0x0,0x0,0x0,0xc,0x7,
    0xff,0x0,0xe,0x7,0x80,0x80,0x10,0x2,0x4,0x0,0x12,0x7,0x8,0xa0,0x14,0x8,0x0,0x1,0xd7,0x7,
    0x8,0xc0,0x18,0x8,0x0,0x0,0x1a,0x7,0x2c,0x0,0x0,0x40,0x0,0x10,0xde,0x3,0x2,0xe0,0x20,0x3,
    0x80,0x19,0x23,0x2,0x18,0xf0,0xe4,0x3,0x80,0x9,0x21,0x2,0x0,0x4,0xe5,0x2,0x18,0xf0,0xe4,0x4,
    0x42,0xe0,0x0,0xf,0x72,0xed,0x61,0x3,0xc4,0x6,0xc2,0x40,0x1,0x0,0x21,0x8,0x0,0xa,0x63,0x2,
    0x3e,0x12,0x41,0x0,0x9,0x68,0xe0,0x0,0x72,0xed,0x61,0x4,0xa0,0xee,0xa1,0x3,0x90,0xee,0xe7,0x3,
    0x4,0xe0,0xa4,0x3,0x83,0x6,0x23,0x0,0xc,0x2,0xe0,0x2,0xa,0x4,0xe1,0x0,0x0,0x1a,0xa3,0x2,
    0x1,0x2,0xe2,0x2,0x40,0x94,0xe0,0x2,0x81,0x38,0x23,0x0,0x0,0xa,0xa1,0x2,0x10,0x28,0xa3,0x70,
    0x10,0xf0,0xe0,0x3,0x1,0xd0,0x1a,0x8,0x80,0xd9,0x9a,0x2,0x80,0x3,0xe3,0x2,0x40,0x14,0xe1,0x2,
    0xae,0xd1,0x0,0x0,0x10,0xf0,0xe0,0x4,0x3,0xe0,0x22,0x4,0x0,0xe0,0x0,0xf,0x76,0xed,0x1d,0x3,
    0x80,0x19,0x1f,0x2,0x1,0xe0,0x9c,0x8,0x76,0xed,0x1d,0x4,0xbc,0x14,0xa2,0x40,0x2,0x0,0x20,0x40,
    0xd,0x1,0x0,0x40,0x48,0xed,0xdd,0x3,0x30,0xed,0x21,0x3,0x37,0xed,0x23,0x3,0x1,0x10,0x25,0x8,
    0x0,0x2a,0x1f,0x2,0x0,0xa,0x27,0x2,0x8e,0xf9,0x0,0x0,0x0,0x1a,0x1f,0x2,0x9,0x69,0xe2,0x0,
    0x4,0x2,0xde,0x2,0x37,0xed,0x23,0x4,0x80,0xe7,0x24,0x1,0xe6,0x7e,0x25,0x49,0x81,0xe7,0x20,0x0,
    0x81,0xe7,0x0,0xe,0x3,0x0,0x23,0x3,0x47,0x81,0x1,0x49,0x80,0x19,0x23,0x2,0x0,0x10,0xe4,0x3,
    0x44,0x6,0xc2,0x40,0x3,0x0,0x23,0x3,0x8,0x20,0xe7,0x3,0x80,0x19,0x23,0x2,0x0,0x14,0xe7,0x2,
    0x8,0x20,0xe7,0x4,0x62,0x0,0x1,0xf,0x36,0xed,0x23,0x3,0x81,0xe7,0x24,0x0,0x1,0x10,0x23,0x8,
    0x36,0xed,0x23,0x4,0x4,0x20,0xa5,0x3,0x68,0xed,0xe7,0x3,0x50,0xed,0x23,0x3,0x57,0xed,0x29,0x3,
    0x1,0x40,0x2d,0x8,0x0,0x6a,0x2b,0x2,0x0,0x1a,0x2f,0x2,0x8e,0x5b,0x1,0x0,0x0,0x4a,0x2b,0x2,
    0x9,0x6b,0xe8,0x0,0x4,0x2,0xea,0x2,0x57,0xed,0x29,0x4,0x80,0x3a,0x2d,0x1,0xe6,0x7e,0x65,0x49,
    0x81,0x3a,0x23,0x0,0x81,0x3a,0x1,0xe,0x3,0x10,0x29,0x3,0x47,0x0,0x45,0x49,0xb,0x0,0x0,0x40,
    0x80,0x49,0x2d,0x2,0x0,0x10,0xe8,0x3,0x58,0x6,0xc2,0x40,0x3,0x10,0x2d,0x3,0x8,0x40,0xef,0x3,
    0x80,0x69,0x2d,0x2,0x0,0x64,0xef,0x2,0x8,0x40,0xef,0x4,0x62,0x10,0x1,0xf,0x2,0x0,0x0,0x40,
    0x0,0x10,0xe8,0x3,0x56,0xed,0x2d,0x3,0x81,0x3a,0x27,0x0,0x81,0xe7,0x1c,0x0,0x1,0x60,0x2d,0x8,
    0x56,0xed,0x2d,0x4,0xa0,0xee,0xad,0x3,0xe0,0xed,0xf1,0x3,0x4,0x30,0xaf,0x3,0x83,0x66,0x2b,0x0,
    0xc,0x2,0xec,0x2,0xa,0x64,0xed,0x0,0x0,0x5a,0xab,0x2,0x1,0x2,0xea,0x2,0x40,0x94,0xec,0x2,
    0x81,0x8a,0x31,0x0,0x0,0x6a,0xad,0x2,0x8,0x8b,0x25,0x71,0x38,0xee,0xe5,0x3,0x81,0x2a,0x25,0x0,
    0x8,0x2b,0x2f,0x71,0x34,0xed,0x65,0x3,0x20,0xa9,0xe0,0x1,0x31,0xed,0x21,0x3,0x1,0x0,0x21,0x8,
    0x31,0xed,0x21,0x4,0x0,0x40,0xe1,0x3,0x80,0x3,0xe5,0x2,0x40,0x24,0xe1,0x2,0x0,0x40,0xe1,0x4,
    0x2,0xe0,0x24,0x4,0x34,0xed,0x5d,0x3,0x80,0x29,0x25,0x2,0x1,0xe0,0x1c,0x8,0x0,0xea,0x5e,0x2,
    0x3e,0xf2,0x40,0x0,0x0,0x10,0xde,0x3,0x9,0x67,0xdc,0x0,0x34,0xed,0x5d,0x4,0x54,0xed,0x5d,0x3,
    0x3,0x2,0xdc,0x2,0x1,0x57,0x1c,0x0,0x8,0xe0,0xe2,0x4,0x51,0xed,0x1d,0x3,0x1,0xe0,0x1c,0x8,
    0x51,0xed,0x1d,0x4,0x0,0xf0,0xdc,0x3,0x80,0xe3,0xe2,0x2,0x40,0x14,0xdd,0x2,0x0,0xf0,0xdc,0x4,
    0x2,0x30,0x23,0x4,0x54,0xed,0x5d,0x3,0x80,0x19,0x23,0x2,0x1,0xe0,0x1c,0x8,0x0,0xea,0x5e,0x2,
    0x3e,0xf2,0x40,0x0,0x9,0x67,0xdc,0x0,0x54,0xed,0x5d,0x4,0x32,0xed,0x61,0x3,0x31,0xed,0x1f,0x3,
    0x0,0xa8,0xdc,0x1,0x1,0xf0,0x9e,0x8,0x31,0xed,0x1f,0x4,0x2,0xe0,0x1e,0x3,0xc8,0x10,0xa2,0x40,
    0x8e,0xf3,0x0,0x0,0xc4,0x10,0xa2,0x40,0xb,0x0,0x20,0x40,0x0,0x10,0xe0,0x3,0x2,0xe0,0x22,0x3,
    0x80,0xf9,0x1e,0x2,0x0,0x0,0xe5,0x3,0x80,0x19,0x23,0x2,0x0,0x14,0xe5,0x2,0x0,0x0,0xe5,0x4,
    0x42,0xe0,0x0,0xf,0x32,0xed,0x61,0x3,0xbc,0x10,0xc2,0x40,0x1,0x0,0x1f,0x8,0x0,0xfa,0x60,0x2,
    0x3e,0x2,0x41,0x0,0x89,0x67,0xde,0x0,0x32,0xed,0x5f,0x4,0x52,0xed,0x63,0x3,0x51,0xed,0x21,0x3,
    0x0,0x18,0x1f,0x2,0x3,0x2,0xde,0x2,0x81,0x57,0x1e,0x0,0x1,0x0,0xa5,0x8,0x8,0xf0,0xde,0x3,
    0x4,0xe0,0xa0,0x3,0x51,0xed,0x25,0x4,0x2,0xf0,0x24,0x3,0x67,0x1,0x21,0x49,0x0,0x10,0xe2,0x3,
    0x2,0xf0,0x26,0x3,0x80,0x29,0x25,0x2,0x0,0x10,0xe9,0x3,0x80,0x39,0x27,0x2,0x0,0x34,0xe9,0x2,
    0x0,0x10,0xe9,0x4,0x42,0xf0,0x0,0xf,0x52,0xed,0x63,0x3,0xc8,0x10,0xc2,0x40,0x1,0x10,0x23,0x8,
    0x0,0x1a,0x65,0x2,0x3e,0x22,0x41,0x0,0x89,0x68,0xe2,0x0,0x52,0xed,0x63,0x4,0x4,0xf0,0xa2,0x3,
    0x88,0xed,0xe5,0x3,0x70,0xed,0x29,0x3,0x77,0xed,0x2b,0x3,0x1,0x50,0x2d,0x8,0x0,0x6a,0x27,0x2,
    0x0,0x4a,0x2f,0x2,0x8e,0x3b,0x1,0x0,0x0,0x5a,0x27,0x2,0x9,0x6b,0xea,0x0,0x4,0x2,0xe6,0x2,
    0x77,0xed,0x2b,0x4,0x80,0x29,0x2d,0x1,0xe6,0x7e,0x65,0x49,0x81,0x29,0x29,0x0,0x81,0x29,0x1,0xe,
    0x3,0x40,0x2b,0x3,0x47,0x80,0x45,0x49,0xb,0x0,0x0,0x40,0x80,0x59,0x2d,0x2,0x0,0x10,0xea,0x3,
    0xd8,0x14,0xc2,0x40,0x3,0x40,0x2d,0x3,0x10,0x50,0xef,0x3,0x80,0x69,0x2d,0x2,0x0,0x64,0xef,0x2,
    0x10,0x50,0xef,0x4,0x62,0x40,0x1,0xf,0x2,0x0,0x0,0x40,0x0,0x10,0xea,0x3,0x76,0xed,0x2d,0x3,
    0x81,0x29,0x25,0x0,0x98,0x0,0x40,0x80,0x1,0x60,0x2d,0x8,0x76,0xed,0x2d,0x4,0xa0,0xee,0xad,0x3,
    0x4,0x20,0xa7,0x3,0x80,0x69,0xad,0x2,0x58,0x0,0x40,0x80,0x80,0x38,0x2c,0x2,0x40,0x4,0xec,0x2,
    0x0,0x69,0x7,0x2,0xac,0x8,0x67,0x85,0x80,0x38,0x20,0x2,0x0,0x4,0xe0,0x2,0x0,0x9,0x7,0x2,
    0x74,0xed,0x61,0x3,0x20,0xc8,0xe8,0x1,0x71,0xed,0x21,0x3,0x88,0x0,0x40,0x80,0x1,0x0,0x21,0x8,
    0x71,0xed,0x21,0x4,0x18,0x50,0xe1,0x3,0x80,0x3,0xe3,0x2,0x40,0x14,0xe1,0x2,0x8,0x0,0x40,0x80,
    0x18,0x50,0xe1,0x4,0x2,0x20,0x23,0x4,0x74,0xed,0x61,0x3,0x1,0x0,0x21,0x8,0x0,0xa,0x65,0x2,
    0x3e,0x22,0x41,0x0,0x0,0x10,0xe4,0x3,0x9,0x68,0xe0,0x0,0x74,0xed,0x61,0x4,0x8,0x20,0xe1,0x3,
    0x80,0x3,0xe7,0x2,0x40,0x34,0xe1,0x2,0x8,0x20,0xe1,0x4,0x3,0xe0,0x26,0x4,0x0,0xe0,0x0,0xf,
    0x36,0xed,0x1d,0x3,0x0,0x10,0xe0,0x3,0x80,0x39,0x27,0x2,0x1,0xe0,0x9c,0x8,0x36,0xed,0x1d,0x4,
    0x8,0x0,0xdd,0x3,0x80,0xe3,0xe4,0x2,0x40,0x24,0xdd,0x2,0x8,0x0,0xdd,0x4,0x3,0xf0,0x24,0x4,
    0x0,0xf0,0x0,0xf,0x56,0xed,0x1d,0x3,0x80,0x19,0x1f,0x2,0x1,0xe0,0x9c,0x8,0x56,0xed,0x1d,0x4,
    0x72,0xed,0x61,0x3,0x71,0xed,0x23,0x3,0xbc,0x6,0xa2,0x40,0x0,0xc8,0xdc,0x1,0x1,0x10,0x9f,0x8,
    0x71,0xed,0x1f,0x4,0x2,0xe0,0x22,0x3,0x80,0x29,0x1f,0x2,0x4c,0x6,0xa2,0x40,0x9e,0x13,0x1,0x0,
    0x3c,0x6,0xa2,0x40,0xcc,0xfe,0x20,0x40,0x0,0x10,0xde,0x3,0xd4,0xfe,0x0,0x40,0x2d,0xed,0x3,0x3,
    0x0,0x0,0x0,0x7,0x60,0x91,0x5,0x48,0xa1,0xe5,0x35,0xf,0x2c,0xed,0x31,0x3,0xa0,0x10,0x81,0x49,
    0xfd,0x6,0x2,0x7,0x0,0x0,0x0,0x7,0x82,0xe0,0x3,0x0,0xff,0x0,0x4,0x7,0x15,0x0,0x6,0x7,
    0x10,0x0,0x8,0x7,0x5,0x0,0xa,0x7,0x4,0x0,0xc,0x7,0x6,0x0,0xe,0x7,0x7,0x0,0x10,0x7,
    0x12,0x0,0x12,0x7,0x11,0x0,0x14,0x7,0x13,0x0,0x16,0x7,0x14,0x0,0x18,0x7,0x1a,0x0,0x1a,0x7,
    0x17,0x0,0x1c,0x7,0x16,0x0,0x1e,0x7,0x18,0x0,0x20,0x7,0x19,0x0,0x22,0x7,0x1c,0x0,0x24,0x7,
    0x1b,0x0,0x26,0x7,0x1d,0x0,0x28,0x7,0x1e,0x0,0x2a,0x7,0x1f,0x0,0x2c,0x7,0xc,0x0,0x0,0x40,
    0x80,0x79,0x2f,0x2,0x5c,0x4,0xc2,0x40,0x2,0x10,0x0,0xf,0x2c,0xed,0x31,0x3,0x1,0x0,0x0,0x8,
    0x0,0xa,0x2e,0x2,0x0,0x8a,0x33,0x2,0xae,0x7c,0x41,0x0,0x10,0x10,0x2,0x8,0x2,0x0,0x20,0x40,
    0x61,0x0,0x0,0x40,0x0,0x10,0x2e,0x3,0x2,0xff,0x61,0x49,0xfe,0x1f,0x30,0x3,0x43,0x0,0x8d,0x49,
    0xb,0x0,0x0,0x40,0xad,0x2,0x8d,0x49,0x4e,0x0,0x8d,0x49,0x29,0x0,0x0,0x40,0x50,0x7,0x81,0x49,
    0x91,0x7,0x81,0x49,0x4d,0x0,0x81,0x49,0xec,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0x5c,0x14,0xc2,0x40,
    0xe9,0xff,0x0,0x40,0x44,0x0,0x8d,0x49,0x13,0x0,0x0,0x40,0x49,0x0,0x8d,0x49,0x24,0x0,0x0,0x40,
    0xab,0x6,0x81,0x49,0xec,0x6,0x81,0x49,0x43,0x0,0x81,0x49,0xe1,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,
    0xdc,0x0,0xc2,0x40,0xde,0xff,0x0,0x40,0x52,0x0,0x8d,0x49,0x21,0x0,0x0,0x40,0x54,0x6,0x81,0x49,
    0x95,0x6,0x81,0x49,0x56,0x0,0x81,0x49,0xd8,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0xdc,0x2a,0xc2,0x40,
    0xd5,0xff,0x0,0x40,0xe5,0x0,0x8d,0x49,0x6,0x6,0x81,0x49,0x45,0x0,0x81,0x49,0xd1,0xff,0x0,0x40,
    0x80,0x79,0x2f,0x2,0x5c,0x6,0xc2,0x40,0xce,0xff,0x0,0x40,0xa7,0x5,0x81,0x49,0x48,0x0,0x81,0x49,
    0xcb,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0xdc,0x6,0xc2,0x40,0xc8,0xff,0x0,0x40,0xaf,0x78,0x81,0x49,
    0x4e,0x0,0x81,0x49,0xc5,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0x5c,0x2,0xc2,0x40,0xc2,0xff,0x0,0x40,
    0x8a,0x4,0x81,0x49,0x49,0x0,0x81,0x49,0xbf,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0x5c,0x29,0xc2,0x40,
    0xbc,0xff,0x0,0x40,0x33,0x4,0x81,0x49,0x52,0x0,0x81,0x49,0xb9,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,
    0x5c,0x2a,0xc2,0x40,0xb6,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0x5c,0x10,0xc2,0x40,0xb3,0xff,0x0,0x40,
    0x80,0x79,0x2f,0x2,0xdc,0x2,0xc2,0x40,0xb0,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0x5c,0x16,0xc2,0x40,
    0xad,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0xdc,0x12,0xc2,0x40,0xaa,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,
    0x5c,0x28,0xc2,0x40,0xa7,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0x5c,0x8,0xc2,0x40,0xa4,0xff,0x0,0x40,
    0x80,0x79,0x2f,0x2,0xdc,0x10,0xc2,0x40,0xa1,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0xdc,0x14,0xc2,0x40,
    0x9e,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,0x5c,0x49,0xc2,0x40,0x9b,0xff,0x0,0x40,0x80,0x79,0x2f,0x2,
    0x5c,0x51,0xc2,0x40,0x98,0xff,0x0,0x40,0x0,0x18,0xe0,0x40,0x0,0x0,0x0,0x7,0x0,0x0,0x2e,0x40,
    0x0,0x80,0x22,0x7,0x10,0x0,0x63,0x7,0x20,0x5,0x1e,0x7,0xf0,0x1f,0xe1,0x3,0x80,0x28,0x1c,0x2,
    0x8a,0xe7,0xdc,0x0,0xb,0x7,0xe1,0x0,0x0,0x0,0x1e,0x7,0xf0,0x1f,0xe1,0x4,0xe0,0x1f,0xe1,0x3,
    0x1f,0xf7,0x1c,0x0,0x8f,0x7,0x21,0x0,0xa,0xe8,0xdc,0x0,0x0,0xe9,0x16,0x2,0x2,0x0,0x20,0x40,
    0xf,0x0,0x0,0x40,0x49,0xfd,0x20,0x7,0x0,0x80,0x22,0x7,0xff,0xff,0x61,0x7,0x10,0x0,0x63,0x7,
    0x80,0x18,0x1c,0x2,0xff,0xff,0xa1,0x7,0xff,0x3f,0xe1,0x7,0xe8,0x1f,0xdd,0x4,0x80,0x8,0x1c,0x2,
    0x2,0x2,0xe0,0x2,0x1,0xe8,0x1c,0x0,0x10,0x0,0x20,0x7,0x1,0xe8,0x1c,0x0,0xe0,0x1f,0xdd,0x4,
    0x0,0x0,0x1e,0x7,0x0,0xf0,0x2e,0x40,0x0,0x0,0x60,0x41,0x1,0x0,0x4,0x0,0x3,0x0,0x0,0x0,
    0x20,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x18,0x0,0x0,0x0,
    0x4c,0x69,0x6e,0x6b,0x65,0x72,0x3a,0x20,0x4c,0x4c,0x44,0x20,0x31,0x35,0x2e,0x30,0x2e,0x35,0x0,0x0,
    0x32,0x30,0x32,0x34,0x2d,0x30,0x31,0x2d,0x31,0x31,0x54,0x32,0x30,0x3a,0x33,0x30,0x3a,0x33,0x31,0x2b,
    0x30,0x38,0x3a,0x30,0x30,0x20,0x63,0x6c,0x61,0x6e,0x67,0x20,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,
    0x31,0x35,0x2e,0x30,0x2e,0x35,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,
    0x4,0x0,0xf1,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x64,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0xc3,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8,0x0,0x0,0x0,0x1,0x0,0x2,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2e,0x1,0x0,0x0,0x0,0x0,0x2,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x33,0x1,0x0,0x0,
    0x0,0x0,0x5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x38,0x1,0x0,0x0,0x0,0x0,0x5,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x3d,0x1,0x0,0x0,0x0,0x0,0x5,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x42,0x1,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x47,0x1,0x0,0x0,0x0,0x0,0x3,0x0,
    0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c,0x1,0x0,0x0,
    0x0,0x0,0x3,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x51,0x1,0x0,0x0,0x0,0x0,0x3,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x56,0x1,0x0,0x0,0x0,0x0,0x3,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5b,0x1,0x0,0x0,0x0,0x0,0x4,0x0,0x13,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x61,0x1,0x0,0x0,0x12,0x0,0x1,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0xba,0x1,0x0,0x0,
    0x21,0x0,0x5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0xd4,0x1,0x0,0x0,0x21,0x0,0x5,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0xe2,0x1,0x0,0x0,0x21,0x0,0x5,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xee,0x1,0x0,0x0,0x21,0x0,0x3,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x49,0x2,0x0,0x0,0x21,0x0,0x3,0x0,
    0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x71,0x2,0x0,0x0,
    0x21,0x0,0x3,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0xa0,0x2,0x0,0x0,0x21,0x0,0x3,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0xcd,0x2,0x0,0x0,0x21,0x0,0x3,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2e,0x74,0x65,0x78,0x74,0x0,0x2e,0x61,0x73,0x63,0x65,
    0x6e,0x64,0x2e,0x6d,0x65,0x74,0x61,0x2e,0x74,0x65,0x5f,0x61,0x64,0x64,0x63,0x75,0x73,0x74,0x6f,0x6d,
    0x5f,0x38,0x64,0x33,0x35,0x65,0x66,0x30,0x62,0x61,0x33,0x66,0x36,0x37,0x30,0x62,0x39,0x32,0x61,0x61,
    0x65,0x33,0x34,0x37,0x34,0x36,0x34,0x30,0x63,0x36,0x33,0x66,0x61,0x34,0x66,0x34,0x61,0x65,0x34,0x62,
    0x36,0x62,0x34,0x38,0x63,0x35,0x39,0x66,0x30,0x66,0x32,0x32,0x64,0x32,0x39,0x62,0x35,0x36,0x31,0x31,
    0x63,0x66,0x38,0x32,0x61,0x5f,0x31,0x5f,0x5f,0x6b,0x65,0x72,0x6e,0x65,0x6c,0x30,0x0,0x5f,0x5f,0x43,
    0x43,0x45,0x5f,0x4b,0x65,0x72,0x6e,0x65,0x6c,0x41,0x72,0x67,0x53,0x69,0x7a,0x65,0x0,0x2e,0x63,0x6f,
    0x6d,0x6d,0x65,0x6e,0x74,0x0,0x2e,0x62,0x6c,0x5f,0x75,0x6e,0x69,0x6e,0x69,0x74,0x0,0x2e,0x73,0x79,
    0x6d,0x74,0x61,0x62,0x0,0x2e,0x73,0x68,0x73,0x74,0x72,0x74,0x61,0x62,0x0,0x2e,0x73,0x74,0x72,0x74,
    0x61,0x62,0x0,0x0,0x74,0x65,0x5f,0x61,0x64,0x64,0x63,0x75,0x73,0x74,0x6f,0x6d,0x5f,0x38,0x64,0x33,
    0x35,0x65,0x66,0x30,0x62,0x61,0x33,0x66,0x36,0x37,0x30,0x62,0x39,0x32,0x61,0x61,0x65,0x33,0x34,0x37,
    0x34,0x36,0x34,0x30,0x63,0x36,0x33,0x66,0x61,0x34,0x66,0x34,0x61,0x65,0x34,0x62,0x36,0x62,0x34,0x38,
    0x63,0x35,0x39,0x66,0x30,0x66,0x32,0x32,0x64,0x32,0x39,0x62,0x35,0x36,0x31,0x31,0x63,0x66,0x38,0x32,
    0x61,0x5f,0x31,0x5f,0x31,0x39,0x36,0x38,0x33,0x32,0x37,0x5f,0x6b,0x65,0x72,0x6e,0x65,0x6c,0x2e,0x63,
    0x70,0x70,0x0,0x74,0x65,0x5f,0x61,0x64,0x64,0x63,0x75,0x73,0x74,0x6f,0x6d,0x5f,0x38,0x64,0x33,0x35,
    0x65,0x66,0x30,0x62,0x61,0x33,0x66,0x36,0x37,0x30,0x62,0x39,0x32,0x61,0x61,0x65,0x33,0x34,0x37,0x34,
    0x36,0x34,0x30,0x63,0x36,0x33,0x66,0x61,0x34,0x66,0x34,0x61,0x65,0x34,0x62,0x36,0x62,0x34,0x38,0x63,
    0x35,0x39,0x66,0x30,0x66,0x32,0x32,0x64,0x32,0x39,0x62,0x35,0x36,0x31,0x31,0x63,0x66,0x38,0x32,0x61,
    0x5f,0x31,0x5f,0x5f,0x6b,0x65,0x72,0x6e,0x65,0x6c,0x30,0x24,0x6c,0x6f,0x63,0x61,0x6c,0x0,0x24,0x78,
    0x2e,0x30,0x0,0x5f,0x5a,0x4c,0x39,0x36,0x74,0x65,0x5f,0x61,0x64,0x64,0x63,0x75,0x73,0x74,0x6f,0x6d,
    0x5f,0x38,0x64,0x33,0x35,0x65,0x66,0x30,0x62,0x61,0x33,0x66,0x36,0x37,0x30,0x62,0x39,0x32,0x61,0x61,
    0x65,0x33,0x34,0x37,0x34,0x36,0x34,0x30,0x63,0x36,0x33,0x66,0x61,0x34,0x66,0x34,0x61,0x65,0x34,0x62,
    0x36,0x62,0x34,0x38,0x63,0x35,0x39,0x66,0x30,0x66,0x32,0x32,0x64,0x32,0x39,0x62,0x35,0x36,0x31,0x31,
    0x63,0x66,0x38,0x32,0x61,0x5f,0x31,0x5f,0x5f,0x6b,0x65,0x72,0x6e,0x65,0x6c,0x30,0x5f,0x73,0x65,0x63,
    0x74,0x69,0x6f,0x6e,0x0,0x24,0x64,0x2e,0x31,0x0,0x24,0x64,0x2e,0x32,0x0,0x24,0x64,0x2e,0x33,0x0,
    0x24,0x64,0x2e,0x34,0x0,0x24,0x64,0x2e,0x35,0x0,0x24,0x64,0x2e,0x36,0x0,0x24,0x64,0x2e,0x37,0x0,
    0x24,0x64,0x2e,0x38,0x0,0x24,0x64,0x2e,0x39,0x0,0x24,0x64,0x2e,0x31,0x30,0x0,0x74,0x65,0x5f,0x61,
    0x64,0x64,0x63,0x75,0x73,0x74,0x6f,0x6d,0x5f,0x38,0x64,0x33,0x35,0x65,0x66,0x30,0x62,0x61,0x33,0x66,
    0x36,0x37,0x30,0x62,0x39,0x32,0x61,0x61,0x65,0x33,0x34,0x37,0x34,0x36,0x34,0x30,0x63,0x36,0x33,0x66,
    0x61,0x34,0x66,0x34,0x61,0x65,0x34,0x62,0x36,0x62,0x34,0x38,0x63,0x35,0x39,0x66,0x30,0x66,0x32,0x32,
    0x64,0x32,0x39,0x62,0x35,0x36,0x31,0x31,0x63,0x66,0x38,0x32,0x61,0x5f,0x31,0x5f,0x5f,0x6b,0x65,0x72,
    0x6e,0x65,0x6c,0x30,0x0,0x67,0x5f,0x73,0x79,0x73,0x56,0x65,0x63,0x57,0x6f,0x72,0x6b,0x73,0x70,0x61,
    0x63,0x65,0x52,0x65,0x73,0x65,0x72,0x76,0x65,0x64,0x0,0x67,0x5f,0x76,0x65,0x63,0x54,0x50,0x69,0x70,
    0x65,0x50,0x74,0x72,0x0,0x67,0x5f,0x72,0x70,0x63,0x43,0x6c,0x69,0x65,0x6e,0x74,0x0,0x74,0x65,0x5f,
    0x61,0x64,0x64,0x63,0x75,0x73,0x74,0x6f,0x6d,0x5f,0x38,0x64,0x33,0x35,0x65,0x66,0x30,0x62,0x61,0x33,
    0x66,0x36,0x37,0x30,0x62,0x39,0x32,0x61,0x61,0x65,0x33,0x34,0x37,0x34,0x36,0x34,0x30,0x63,0x36,0x33,
    0x66,0x61,0x34,0x66,0x34,0x61,0x65,0x34,0x62,0x36,0x62,0x34,0x38,0x63,0x35,0x39,0x66,0x30,0x66,0x32,
    0x32,0x64,0x32,0x39,0x62,0x35,0x36,0x31,0x31,0x63,0x66,0x38,0x32,0x61,0x5f,0x31,0x5f,0x5f,0x6b,0x65,
    0x72,0x6e,0x65,0x6c,0x30,0x5f,0x5f,0x0,0x5f,0x5a,0x4e,0x37,0x41,0x73,0x63,0x65,0x6e,0x64,0x43,0x31,
    0x36,0x47,0x65,0x74,0x55,0x73,0x65,0x72,0x57,0x6f,0x72,0x6b,0x73,0x70,0x61,0x63,0x65,0x45,0x50,0x55,
    0x33,0x41,0x53,0x31,0x68,0x5f,0x5f,0x0,0x5f,0x5a,0x4e,0x4b,0x37,0x41,0x73,0x63,0x65,0x6e,0x64,0x43,
    0x31,0x32,0x47,0x6c,0x6f,0x62,0x61,0x6c,0x54,0x65,0x6e,0x73,0x6f,0x72,0x49,0x44,0x68,0x45,0x31,0x30,
    0x47,0x65,0x74,0x50,0x68,0x79,0x41,0x64,0x64,0x72,0x45,0x76,0x5f,0x5f,0x0,0x5f,0x5a,0x4e,0x37,0x41,
    0x73,0x63,0x65,0x6e,0x64,0x43,0x31,0x33,0x52,0x70,0x63,0x43,0x6f,0x6d,0x6d,0x43,0x6c,0x69,0x65,0x6e,
    0x74,0x31,0x32,0x41,0x6c,0x6c,0x6f,0x63,0x4d,0x65,0x73,0x73,0x61,0x67,0x65,0x45,0x76,0x5f,0x5f,0x0,
    0x5f,0x5a,0x4e,0x37,0x41,0x73,0x63,0x65,0x6e,0x64,0x43,0x31,0x36,0x41,0x6c,0x6c,0x6f,0x63,0x4d,0x65,
    0x73,0x73,0x61,0x67,0x65,0x49,0x6d,0x70,0x6c,0x45,0x52,0x50,0x55,0x33,0x41,0x53,0x31,0x4e,0x53,0x5f,
    0x36,0x52,0x70,0x63,0x4d,0x73,0x67,0x45,0x52,0x68,0x53,0x33,0x5f,0x5f,0x5f,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x14,0xb,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc4,0xb,0x0,0x0,0x0,0x0,0x0,0x0,
    0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6d,0x0,0x0,0x0,0x1,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcc,0xb,0x0,0x0,
    0x0,0x0,0x0,0x0,0x14,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x81,0x0,0x0,0x0,
    0x1,0x0,0x0,0x0,0x30,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0xe0,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x43,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x8a,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x23,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x95,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x28,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x2,0x0,0x0,
    0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0xf,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x18,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9d,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x68,0xe,0x0,0x0,0x0,0x0,0x0,0x0,
    0xaf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x3,0x0,0x0,0x0,
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x17,0xf,0x0,0x0,
    0x0,0x0,0x0,0x0,0x5,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
    0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
};
    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;
    bool isSupportMix = false;
    MOCKER(ConvertTaskRation).stubs().will(returnValue(RT_ERROR_INVALID_VALUE));
    kernels = ProcessObject((char_t *)static_kernel_data, elfData, 0, &isSupportMix);

    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    delete elfData;
    elfData = NULL;
    if (kernels != nullptr) {
        delete [] kernels;
        kernels = NULL;
    }
}


TEST_F(CloudV2ELFTest, ELF_UPDATE_FUNC_TYPE_BY_PROG_TYPE)
{
    ElfKernelInfo kernelInfo;
    kernelInfo.funcType = KERNEL_FUNCTION_TYPE_INVALID;
    bool isUpdate = false;
    uint32_t progType = Program::MACH_AI_CPU;

    UpdateFuncTypeByProgType(&kernelInfo, progType, &isUpdate);
    EXPECT_EQ(kernelInfo.funcType, KERNEL_FUNCTION_TYPE_INVALID);
    EXPECT_EQ(isUpdate, false);

    isUpdate = true;
    UpdateFuncTypeByProgType(&kernelInfo, progType, &isUpdate);
    EXPECT_EQ(kernelInfo.funcType, KERNEL_FUNCTION_TYPE_INVALID);
    EXPECT_EQ(isUpdate, false);
}

TEST_F(CloudV2ELFTest, ELF_Process_Object_01)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    //bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/elf.o", "rb");
    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/conv_fwd_sample.cce.tmp", "rb");
    //bin = fopen("conv_fwd_sample.cce.out", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;
    bool isSupportMix = false;

    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num, 1);

    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    for (uint32_t i = 0; i < elfData->kernel_num; ++i) {
        if (kernels != nullptr) {
            DELETE_A(kernels[i].name);
        }
    }
    delete elfData;
    elfData = NULL;
    delete [] kernels;
    kernels = NULL;
}

TEST_F(CloudV2ELFTest, ELF_Process_Object_02)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/elf.o", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;
    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    for (uint32_t i = 0; i < elfData->kernel_num; ++i) {
        if (kernels != nullptr) {
            DELETE_A(kernels[i].name);
        }
    }
    delete [] kernels;
    kernels = NULL;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);

    EXPECT_EQ(elfData->kernel_num,1);

    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    for (uint32_t i = 0; i < elfData->kernel_num; ++i) {
        if (kernels != nullptr) {
            DELETE_A(kernels[i].name);
        }
    }
    delete elfData;
    elfData = NULL;
    delete [] kernels;
    kernels = NULL;
}

TEST_F(CloudV2ELFTest, ELF_Process_Object_03)
{
    size_t MAX_LENGTH = 6144;
    FILE *bin = NULL;

    //bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/bad-elf2.o", "rb");
    bin = fopen("bad-elf2.o", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;
    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num, 1);
    if(NULL == kernels)
    {
        printf("SUCC get 64bit section headers failed!\n");
    }
    else
    {
        printf("FAIL\n");
    }

    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    delete elfData;
    elfData = NULL;
    delete [] kernels;
    kernels = NULL;
}

TEST_F(CloudV2ELFTest, ELF_Process_Object_04)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/bad-elf3.o", "rb");
    //bin = fopen("bad-elf3.o", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;
    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num, 0);

    if(NULL == kernels)
    {
        printf("SUCC get 64bit section headers failed!\n");
    }
    else
    {
        printf("FAIL\n");
    }

    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    delete elfData;
    elfData = NULL;
    delete [] kernels;
    kernels = NULL;
}

TEST_F(CloudV2ELFTest, ELF_Process_Object_05)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/bad-elf4.o", "rb");
    //bin = fopen("bad-elf4.o", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;
    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num,0);

    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    delete elfData;
    elfData = NULL;
    delete [] kernels;
    kernels = NULL;
}

TEST_F(CloudV2ELFTest, ELF_Process_Object_06)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/no-kernel.o", "rb");
    //bin = fopen("no-kernel.o", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;
    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num,0);

    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    delete elfData;
    elfData = NULL;
    delete [] kernels;
    kernels = NULL;
}

TEST_F(CloudV2ELFTest, ELF_Process_Object_07)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/bad-elf.o", "rb");
    //bin = fopen("bad-elf.o", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;
    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num,0);

    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    delete elfData;
    elfData = NULL;
    delete [] kernels;
    kernels = NULL;
}

TEST_F(CloudV2ELFTest, ELF_GetStringTableCopy_memcpy_fail)
{
    char buf[20] = {0};
    MOCKER(memcpy_s).stubs().will(returnValue(3));
    std::unique_ptr<char_t[]> out = GetStringTableCopy(&buf[0], 20);
    uint16_t ret = strcmp((char*)&out, "");
    EXPECT_EQ(ret, 0);
}

TEST_F(CloudV2ELFTest, ELF_Little_endian_case)
{
    const unsigned char* field = (unsigned char*)"1234567890";
    unsigned long out;
    out = ByteGetLittleEndian(field, 3);
    uint16_t ret = strcmp((char*)&out, "123");
    EXPECT_EQ(ret, 0);

    out = ByteGetLittleEndian(field, 5);
    ret = strcmp((char*)&out, "12345");
    EXPECT_EQ(ret, 0);

    out = ByteGetLittleEndian(field, 6);
    ret = strcmp((char*)&out, "123456");
    EXPECT_EQ(ret, 0);
    out = ByteGetLittleEndian(field, 7);
    ret = strcmp((char*)&out, "1234567");
    EXPECT_EQ(ret, 0);

}

TEST_F(CloudV2ELFTest, ELF_Big_endian_case)
{
    const unsigned char* field = (unsigned char*)"1234567890";
    unsigned long temp;
    temp = ByteGetBigEndian(field, 1);
    uint16_t ret = strcmp((char*)&temp, "1");
    EXPECT_EQ(ret, 0);
    temp = ByteGetBigEndian(field, 2);
    ret = strcmp((char*)&temp, "21");
    EXPECT_EQ(ret, 0);
    temp = ByteGetBigEndian(field, 3);
    ret = strcmp((char*)&temp, "321");
    EXPECT_EQ(ret, 0);
    temp = ByteGetBigEndian(field, 4);
    ret = strcmp((char*)&temp, "4321");
    EXPECT_EQ(ret, 0);
    temp = ByteGetBigEndian(field, 5);
    ret = strcmp((char*)&temp, "54321");
    EXPECT_EQ(ret, 0);
    temp = ByteGetBigEndian(field, 6);
    ret = strcmp((char*)&temp, "654321");
    EXPECT_EQ(ret, 0);
    temp = ByteGetBigEndian(field, 7);
    ret = strcmp((char*)&temp, "7654321");
    EXPECT_EQ(ret, 0);
    unsigned long out[2];
    out[0] = ByteGetBigEndian(field, 8);
    char *outChar = (char*)out;
    outChar[8] = '\0';

}

TEST_F(CloudV2ELFTest, ELF_Get_64bit_Section_Headers_Error_02)
{
    rtElfData *elfData;
    int out;
    elfData = new rtElfData;
    if (NULL != elfData)
    {
        memset_s(elfData,sizeof(rtElfData),'\0',sizeof(rtElfData));
    }
    elfData->elf_header.e_shentsize = 0;
    elfData->elf_header.e_shnum = 0;

    out = Get64bitSectionHeaders(elfData);
    EXPECT_EQ(out,1);

    elfData->elf_header.e_shentsize = 1;
    elfData->elf_header.e_shnum = 1;

    out = Get64bitSectionHeaders(elfData);
    EXPECT_EQ(out,1);

    elfData->elf_header.e_shentsize = 100;
    elfData->elf_header.e_shnum = 1;

    out = Get64bitSectionHeaders(elfData);
    EXPECT_EQ(out,1);

    if (NULL != elfData)
    {
        if(NULL != elfData->section_headers)
        {
            delete [] elfData->section_headers;
            elfData->section_headers = NULL;
        }

        delete elfData;
        elfData = NULL;
    }
}

TEST_F(CloudV2ELFTest, ELF_Get_64bit_Elf_Symbols_Error_01)
{
    rtElfData *elfData;
    Elf_Internal_Shdr *section;
    unsigned long num_syms_return = 0;
    elfData = new rtElfData;

    if (NULL != elfData)
    {
        memset_s(elfData,sizeof(rtElfData),'\0',sizeof(rtElfData));
    }
    section= new Elf_Internal_Shdr;
    if (NULL != section)
    {
        memset_s(section,sizeof(Elf_Internal_Shdr),'\0',sizeof(Elf_Internal_Shdr));
    }
    section->sh_size = 0;
    std::unique_ptr<Elf_Internal_Sym[]> out = Get64bitElfSymbols(elfData, section, &num_syms_return);
    EXPECT_EQ(elfData->kernel_num,0);
    if (NULL != elfData)
    {
        if(NULL != elfData->section_headers)
        {
            delete [] elfData->section_headers;
            elfData->section_headers = NULL;
        }

        delete elfData;
        elfData = NULL;
    }
    if (NULL != section)
    {
        delete section;
        section = NULL;
    }

}

TEST_F(CloudV2ELFTest, ELF_Get_64bit_Elf_Symbols_Error_02)
{
    rtElfData *elfData;
    Elf_Internal_Shdr *section;
    unsigned long num_syms_return = 0;
    elfData = new rtElfData;
    if (NULL != elfData)
    {
        memset_s(elfData,sizeof(rtElfData),'\0',sizeof(rtElfData));
    }
    section= new Elf_Internal_Shdr;
    if (NULL != section)
    {
        memset_s(section,sizeof(Elf_Internal_Shdr),'\0',sizeof(Elf_Internal_Shdr));
    }
    section->sh_size = 1;
    section->sh_entsize = 0;
    std::unique_ptr<Elf_Internal_Sym[]> out = Get64bitElfSymbols(elfData, section, &num_syms_return);
    EXPECT_EQ(elfData->kernel_num,0);
    if (NULL != elfData)
    {
        if(NULL != elfData->section_headers)
        {
            delete [] elfData->section_headers;
            elfData->section_headers = NULL;
        }

        delete elfData;
        elfData = NULL;
    }
    if (NULL != section)
    {
        delete section;
        section = NULL;
    }

}

TEST_F(CloudV2ELFTest, ELF_Get_64bit_Elf_Symbols_Error_03)
{
    rtElfData *elfData;
    Elf_Internal_Shdr *section;
    unsigned long num_syms_return = 0;
    elfData = new rtElfData;;
    if (NULL != elfData)
    {
        memset_s(elfData,sizeof(rtElfData),'\0',sizeof(rtElfData));
    }
    section= new Elf_Internal_Shdr;
    if (NULL != section)
    {
        memset_s(section,sizeof(Elf_Internal_Shdr),'\0',sizeof(Elf_Internal_Shdr));
    }
    section->sh_size = 2;
    section->sh_entsize = 1;
    std::unique_ptr<Elf_Internal_Sym[]> out = Get64bitElfSymbols(elfData, section, &num_syms_return);
    EXPECT_EQ(elfData->kernel_num,0);
    if (NULL != elfData)
    {
        if(NULL != elfData->section_headers)
        {
            delete [] elfData->section_headers;
            elfData->section_headers = NULL;
        }

        delete elfData;
        elfData = NULL;
    }
    if (NULL != section)
    {
        delete section;
        section = NULL;
    }

}

TEST_F(CloudV2ELFTest, ELF_Process_Object_Error)
{
    rtElfData *elfData;
    RtKernel* out;
    char *obj_buf = NULL;

    elfData = new rtElfData;
    if (NULL != elfData)
    {
        memset_s(elfData,sizeof(rtElfData),'\0',sizeof(rtElfData));
    }
    bool isSupportMix = false;
    out = ProcessObject(obj_buf, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num,0);
    if (NULL != elfData)
    {
        if(NULL != elfData->section_headers)
        {
            delete [] elfData->section_headers;
            elfData->section_headers = NULL;
        }

        delete elfData;
        elfData = NULL;
    }

}

/* UT for elf.cc ByteGetLittleEndian() "default" Line:102*/
TEST_F(CloudV2ELFTest, ELF_BYTE_GET_LITTLE_ENDIAN_TEST)
{
    const unsigned char* field = (unsigned char*)"1234567890";
    unsigned long out;

	MOCKER(abort).stubs().will(returnValue(0));

    out = ByteGetLittleEndian(field, 9);
    uint16_t ret = strcmp((char*)&out, "");
    EXPECT_EQ(ret, 0);
}

/* UT for elf.cc ByteGetBigEndian() "default" Line:136*/
TEST_F(CloudV2ELFTest, ELF_BYTE_GET_BIG_ENDIAN_TEST)
{
    const unsigned char* field = (unsigned char*)"1234567890";
    unsigned long temp;

    MOCKER(abort).stubs().will(returnValue(0));

    temp = ByteGetBigEndian(field, 9);
    uint16_t ret = strcmp((char*)&temp, "");
    EXPECT_EQ(ret, 0);
}

TEST_F(CloudV2ELFTest, ELF_Process_Object_08)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/conv_fwd_sample.cce.tmp", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData *elfData;
    RtKernel *kernels;

    elfData = new rtElfData;
    elfData->elf_header.e_shnum = 1;

    Elf_Internal_Shdr *section_headers = new Elf_Internal_Shdr;
    section_headers->sh_size = 0;
    elfData->section_headers = section_headers;

    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num,1);
    delete [] kernels[0].name;
    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    delete elfData;
    elfData = NULL;
    delete []kernels;
    kernels = NULL;
    delete section_headers;
}

int num_stub = 1;
extern "C" void *__real_malloc (size_t c);
void *malloc_stub_elf(unsigned int num_bytes)
{
    if (7 == num_stub)
    {
        return NULL;
    }
    num_stub++;
    return __real_malloc(num_bytes);
}

TEST_F(CloudV2ELFTest, ELF_Process_Object_09)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/conv_fwd_sample.cce.tmp", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData *elfData;
    RtKernel *kernels;

    elfData= (rtElfData*)malloc(sizeof(rtElfData));
    elfData->elf_header.e_shnum = 1;

    Elf_Internal_Shdr *section_headers = (Elf_Internal_Shdr *)malloc(sizeof(Elf_Internal_Shdr));
    section_headers->sh_size = 0;
    elfData->section_headers = section_headers;

    MOCKER(malloc).stubs().will(invoke(malloc_stub_elf));

    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num,1);
    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    for (uint32_t i = 0; i < elfData->kernel_num; ++i) {
        if (kernels != nullptr) {
            DELETE_A(kernels[i].name);
        }
    }
    free(elfData);
    elfData = NULL;
    delete []kernels;
    kernels = NULL;
    free(section_headers);
}


TEST_F(CloudV2ELFTest, ELF_Process_Object_10)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/conv_fwd_sample.cce.tmp", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData *elfData;
    RtKernel *kernels;

    elfData = new rtElfData;
    elfData->elf_header.e_shnum = 0;

    Elf_Internal_Shdr *section_headers = new Elf_Internal_Shdr;
    section_headers->sh_size = 0;
    elfData->section_headers = section_headers;
    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num,1);
    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    for (uint32_t i = 0; i < elfData->kernel_num; ++i) {
        if (kernels != nullptr) {
            DELETE_A(kernels[i].name);
        }
    }
    delete elfData;
    elfData = NULL;
    delete []kernels;
    kernels = NULL;
    delete section_headers;
}


TEST_F(CloudV2ELFTest, ELF_Process_Object_11)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/conv_fwd_sample.cce.tmp", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);
    bindata[5] = 2;

    rtElfData *elfData;
    RtKernel *kernels;

    elfData = new rtElfData;
    elfData->elf_header.e_shnum = 0;

    Elf_Internal_Shdr *section_headers = new Elf_Internal_Shdr;
    section_headers->sh_size = 0;
    elfData->section_headers = section_headers;

    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    EXPECT_EQ(elfData->kernel_num,0);
    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    delete elfData;
    elfData = NULL;
    delete [] kernels;
    kernels = NULL;
    delete section_headers;
}

#ifdef AICPU_ON_OS
TEST_F(CloudV2ELFTest, ELF_Process_Object_12)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = NULL;

    //bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/elf.o", "rb");
    //bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/libXv.so.1.0.0.txt", "rb");
    bin = fopen("/usr/lib/x86_64-linux-gnu/libXv.so.1.0.0", "rb");
    //bin = fopen("conv_fwd_sample.cce.out", "rb");
    if (bin == NULL)
    {
        printf("error\n");
        return;
    }
    else
    {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;
    memset(elfData, '\0', sizeof(rtElfData));

    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);

    EXPECT_NE(elfData->so_name, (char *)NULL);

    printf ("Library soname: [%s]\n", elfData->so_name);

    if(NULL != elfData->section_headers)
    {
        delete [] elfData->section_headers;
        elfData->section_headers = NULL;
    }
    delete elfData;
    elfData = NULL;
    delete []kernels;
    kernels = NULL;
}
#endif /* AICPU_ON_OS */

TEST_F(CloudV2ELFTest, ELF_Process_Object_15)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = nullptr ;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/no-kernel.o", "rb");
    if (bin == nullptr ) {
        printf("error\n");
        return;
    } else {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData    *elfData;
    RtKernel    *kernels;

    elfData = new rtElfData;

    bool isSupportMix = false;
    kernels = ProcessObject(bindata, elfData, false, &isSupportMix);
    if(nullptr  == kernels) {
        printf("SUCC no kernel!\n");
    } else {
        printf("FAIL\n");
    }

    if(nullptr  != elfData->section_headers) {
        delete [] elfData->section_headers;
        elfData->section_headers = nullptr ;
    }

    uint8_t buf[4096] = {0};
    uint8_t *bufPtr = buf;
    uint32_t totalLen = sizeof(ElfDfxInfo);
    ElfDfxInfo *typeInfo = (ElfDfxInfo *)bufPtr;
    typeInfo->head.type = FUNC_META_TYPE_DFX_TYPE;
    typeInfo->head.length = 100U;
    ElfKernelInfo kernelInfo = {5U, 0U, {1U, 3U}, bufPtr, 108U, false, false, 1U};
    GetKernelTlvInfo(buf, 150U, &kernelInfo);
    EXPECT_EQ(kernelInfo.dfxSize, 108U);
    EXPECT_EQ(kernelInfo.dfxAddr, bufPtr);

    delete elfData;
    elfData = nullptr ;
    delete [] kernels;
    kernels = nullptr ;
}

TEST_F(CloudV2ELFTest, ELF_CONVERT_TASK_RATION_01)
{
    uint32_t taskRation = 2;
    rtError_t  error = ConvertTaskRation(nullptr, taskRation);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);
}

TEST_F(CloudV2ELFTest, ELF_CONVERT_TASK_RATION_02)
{
    uint32_t taskRation = 2;
    ElfKernelInfo elfKernelInfo = {5U, 0U, {2U, 1U}};
    rtError_t  error = ConvertTaskRation(&elfKernelInfo, taskRation);
    EXPECT_EQ(error, RT_ERROR_NONE);
}

TEST_F(CloudV2ELFTest, ELF_CONVERT_TASK_RATION_03)
{
    uint32_t taskRation = 2;
    ElfKernelInfo elfKernelInfo = {4U, 0U, {1U, 1U}};
    rtError_t  error = ConvertTaskRation(&elfKernelInfo, taskRation);
    EXPECT_EQ(error, RT_ERROR_NONE);
}

TEST_F(CloudV2ELFTest, ELF_CONVERT_TASK_RATION_04)
{
    uint32_t taskRation = 2;
    ElfKernelInfo elfKernelInfo = {4U, 0U, {1U, 0U}};
    rtError_t  error = ConvertTaskRation(&elfKernelInfo, taskRation);
    EXPECT_EQ(error, RT_ERROR_NONE);
}

TEST_F(CloudV2ELFTest, ELF_CONVERT_TASK_RATION_05)
{
    uint32_t taskRation = 2;
    ElfKernelInfo elfKernelInfo = {5U, 0U, {1U, 0U}};
    rtError_t  error = ConvertTaskRation(&elfKernelInfo, taskRation);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);
}

TEST_F(CloudV2ELFTest, ELF_CONVERT_TASK_RATION_06)
{
    uint32_t taskRation = 2;
    ElfKernelInfo elfKernelInfo = {4U, 0U, {1U, 3U}};
    rtError_t  error = ConvertTaskRation(&elfKernelInfo, taskRation);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);
}

TEST_F(CloudV2ELFTest, ELF_GET_MIX_STATUS_01)
{
    uint32_t funcType = 1U;
    uint32_t crossCoreSync = 0U;

    bool isMix = GetMixStatus(funcType, crossCoreSync);
    EXPECT_EQ(isMix, false);
}

TEST_F(CloudV2ELFTest, ELF_GET_MIX_STATUS_02)
{
    uint32_t funcType = 2U;
    uint32_t crossCoreSync = 1U;

    bool isMix = GetMixStatus(funcType, crossCoreSync);
    EXPECT_EQ(isMix, true);
}

TEST_F(CloudV2ELFTest, ELF_GET_MIX_STATUS_03)
{
    uint32_t funcType = 3U;
    uint32_t crossCoreSync = 1U;

    bool isMix = GetMixStatus(funcType, crossCoreSync);
    EXPECT_EQ(isMix, true);
}

TEST_F(CloudV2ELFTest, ELF_GET_MIX_STATUS_04)
{
    uint32_t funcType = 8U;
    uint32_t crossCoreSync = 1U;

    bool isMix = GetMixStatus(funcType, crossCoreSync);
    EXPECT_EQ(isMix, false);
}

TEST_F(CloudV2ELFTest, ParseElfStackInfoHeader)
{
    rtElfData *elfData = new rtElfData;

    elfData->stackSize = 0ULL;
    elfData->elf_header.e_version = 0x5a5a0301;
    ParseElfStackInfoHeader(elfData);
    EXPECT_EQ(elfData->stackSize, 0ULL);

    elfData->elf_header.e_version = 0x5a5a0101;
    ParseElfStackInfoHeader(elfData);
    EXPECT_EQ(elfData->stackSize, 16384U);

    elfData->elf_header.e_version = 0x5a5a0201;
    ParseElfStackInfoHeader(elfData);
    EXPECT_EQ(elfData->stackSize, 32768U);

    delete elfData;
    elfData = NULL;
}

TEST_F(CloudV2ELFTest, UpdateKernelsInfo)
{
    rtElfData elfData = {};
    elfData.kernel_num = 1;
    bool isSupportMix = true;

    RtKernel newKernels;
    newKernels.name = new (std::nothrow) char[5];
    strcpy_s(newKernels.name, 5, "test");
    newKernels.offset = 0;
    newKernels.length = 1;
    newKernels.funcType = 1;
    newKernels.crossCoreSync = 1;
    newKernels.taskRation = 1;
    newKernels.dfxSize = 1;

    ElfKernelInfo * kernelInfo = new (std::nothrow) ElfKernelInfo();
    if (kernelInfo == nullptr) {
        return;
    }
    kernelInfo->funcType = KERNEL_FUNCTION_TYPE_INVALID;
    kernelInfo->crossCoreSync = FUNC_NO_USE_SYNC;
    kernelInfo->taskRation[0] = 0U; // init value 0
    kernelInfo->taskRation[1] = 0U; // init value 0
    kernelInfo->dfxAddr = nullptr;
    kernelInfo->dfxSize = 0ULL;
    std::map<std::string, ElfKernelInfo *> kernelInfoMap;

    std::string kernelName = "test-update-kernels-info";
    kernelInfoMap[kernelName] = kernelInfo;

    rtError_t rtn = UpdateKernelsInfo(kernelInfoMap, &newKernels, &elfData, &isSupportMix);
    EXPECT_EQ(rtn, RT_ERROR_INVALID_VALUE);
    delete [] newKernels.name;
    delete kernelInfo;
    kernelInfo = NULL;

}

TEST_F(CloudV2ELFTest, GetMetaInfo)
{
    rtElfData   *elfData = nullptr;
    rtBinaryMetaType      BinaryTLVType = RT_BINARY_TYPE_BIN_VERSION;
    rtFunctionMetaType    FuncTLVType = RT_FUNCTION_TYPE_KERNEL_TYPE;
    rtError_t   error;

    uint64_t data = 0;
    uint32_t length = 4;

    error = GetBinaryMetaInfo(elfData, BinaryTLVType, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);

    error = GetFunctionMetaInfo(elfData, "", FuncTLVType, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);

    elfData = new rtElfData;
    elfData->elf_header.e_shstrndx = 0;
    elfData->elf_header.e_shnum = 3;
    // 0 string sec, 1 binary meta info, 2 func meta info
    elfData->section_headers = new Elf_Internal_Shdr[3];

    elfData->section_headers[0].sh_size = 0;
    error = GetBinaryMetaInfo(elfData, BinaryTLVType, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);

    error = GetFunctionMetaInfo(elfData, "", FuncTLVType, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);

    elfData->obj_size = 1;
    elfData->section_headers[0].sh_size = 1;
    elfData->section_headers[0].sh_offset = 1;
    error = GetFunctionMetaInfo(elfData, "", FuncTLVType, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);

    elfData->obj_size = (~(static_cast<uint64_t>(0)));
    elfData->section_headers[0].sh_size = (~(static_cast<uint64_t>(0)));
    elfData->section_headers[0].sh_offset = 0;
    elfData->obj_ptr_origin = nullptr;
    error = GetFunctionMetaInfo(elfData, "", FuncTLVType, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);

    delete[] elfData->section_headers;
    elfData->section_headers = nullptr;

    delete elfData;
    elfData = nullptr;
}

TEST_F(CloudV2ELFTest, rtGetMetaInfo)
{
    ElfProgram *prog = new ElfProgram();
    PlainProgram *prog2 = new PlainProgram();
    Kernel *funcHandle = new Kernel("func", "func", "func");
    uint64_t data = 0;
    uint32_t length = 0;
    rtError_t error;

    delete prog->elfData_;
    prog->elfData_ = nullptr;
    funcHandle->program_ = RtPtrToPtr<Program *>(prog);

    error = rtBinaryGetMetaInfo(nullptr, RT_BINARY_TYPE_BIN_VERSION, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, ACL_ERROR_RT_PARAM_INVALID);

    error = rtBinaryGetMetaInfo(RtPtrToPtr<rtBinHandle>(prog), RT_BINARY_TYPE_BIN_VERSION, nullptr, length);
    EXPECT_EQ(error, ACL_ERROR_RT_PARAM_INVALID);

    error = rtBinaryGetMetaInfo(RtPtrToPtr<rtBinHandle>(prog), RT_BINARY_TYPE_BIN_VERSION, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, ACL_ERROR_RT_PARAM_INVALID);

    error = rtBinaryGetMetaInfo(RtPtrToPtr<rtBinHandle>(prog2), RT_BINARY_TYPE_BIN_VERSION, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, ACL_RT_SUCCESS);

    error = rtFunctionGetMetaInfo(nullptr, RT_FUNCTION_TYPE_KERNEL_TYPE, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, ACL_ERROR_RT_PARAM_INVALID);

    error = rtFunctionGetMetaInfo(RtPtrToPtr<rtFuncHandle>(funcHandle), RT_FUNCTION_TYPE_KERNEL_TYPE, nullptr, length);
    EXPECT_EQ(error, ACL_ERROR_RT_PARAM_INVALID);

    error = rtFunctionGetMetaInfo(RtPtrToPtr<rtFuncHandle>(funcHandle), RT_FUNCTION_TYPE_INVALID, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, ACL_ERROR_RT_PARAM_INVALID);

    error = rtFunctionGetMetaInfo(RtPtrToPtr<rtFuncHandle>(funcHandle), RT_FUNCTION_TYPE_KERNEL_TYPE, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, ACL_ERROR_RT_PARAM_INVALID);

    funcHandle->program_ = RtPtrToPtr<Program *>(prog2);
    error = rtFunctionGetMetaInfo(RtPtrToPtr<rtFuncHandle>(funcHandle), RT_FUNCTION_TYPE_KERNEL_TYPE, RtPtrToPtr<void *>(&data), length);
    EXPECT_EQ(error, ACL_RT_SUCCESS);

    delete prog;
    delete prog2;
    delete funcHandle;
}

TEST_F(CloudV2ELFTest, ElfParseTlvInfo_Function_Entry)
{
    ElfKernelFunctionEntryInfo kernelFunctionEntryInfo;
    kernelFunctionEntryInfo.head.type = FUNCTION_META_TYPE_FUNCTION_ENTRY_INFO;
    kernelFunctionEntryInfo.head.length = sizeof(ElfKernelFunctionEntryInfo) - sizeof(ElfTlvHead);
    kernelFunctionEntryInfo.functionEntry = 0;
    ElfKernelInfo tlvInfo;

    GetKernelTlvInfo(RtPtrToPtr<uint8_t *>(&kernelFunctionEntryInfo), sizeof(ElfKernelFunctionEntryInfo), &tlvInfo);
    EXPECT_EQ(tlvInfo.functionEntry, 0);
}

TEST_F(CloudV2ELFTest, SetKernelFunctionEntry)
{
    rtError_t error;
    const uint32_t kernelsNum = 2;
    RtKernel kernel[kernelsNum];
    kernel[0].name = "symbol00";
    kernel[1].name = "symbol01";
    std::map<std::string, ElfKernelInfo *> kernelInfoMap;
    ElfKernelInfo info1;
    info1.functionEntryFlag = 0U;
    info1.isSupportFuncEntry = true;
    kernelInfoMap["symbol00"] = &info1;
    ElfKernelInfo info2;
    info2.functionEntryFlag = KERNEL_FUNCTION_ENTRY_DISABLE;
    info2.isSupportFuncEntry = true;
    kernelInfoMap["symbol01"] = &info2;

    error = SetKernelFunctionEntry(kernel, kernelsNum, kernelInfoMap);
    EXPECT_EQ(error, RT_ERROR_NONE);

    RtKernel kernelArr[1];
    kernelArr[0].name = "symbol00";
    info1.functionEntryFlag = 1U;

    error = SetKernelFunctionEntry(kernelArr, 1, kernelInfoMap);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);
}

TEST_F(CloudV2ELFTest, ELF_Process_SetKernelFunctionEntry_Failed)
{
    size_t MAX_LENGTH = 75776;
    FILE *bin = nullptr;

    bin = fopen("llt/ace/npuruntime/runtime/ut/runtime/test/data/elf.o", "rb");
    if (bin == nullptr) {
        printf("error\n");
        return;
    } else {
        printf("succ\n");
    }

    char bindata[MAX_LENGTH];
    fread(bindata, sizeof(char), MAX_LENGTH, bin);
    fclose(bin);

    rtElfData *elfData;
    RtKernel *kernels;

    elfData = new rtElfData;

    bool isSupportMix = false;
    MOCKER(SetKernelFunctionEntry).stubs().will(returnValue(1));
    kernels = ProcessObject(bindata, elfData, 0, &isSupportMix);
    if (nullptr == kernels) {
        printf("SUCC no kernel!\n");
    } else {
        printf("FAIL\n");
    }

    if (nullptr != elfData->section_headers) {
        delete[] elfData->section_headers;
        elfData->section_headers = nullptr;
    }

    if (elfData != nullptr) {
        delete elfData;
        elfData = nullptr;
    }
    if (kernels != nullptr) {
        delete[] kernels;
        kernels = nullptr;
    }
}

TEST_F(CloudV2ELFTest, UnifiedOneKernelRegister_Function_Entry)
{
    rtError_t error;
    ElfProgram prog;
    RtKernel kernel;
    kernel.name = "symbol";
    kernel.simtFlag = false;
    kernel.funcEntryType = KernelFunctionEntryType::KERNEL_TYPE_FUNCTION_ENTRY;
    MOCKER_CPP(&ElfProgram::CreateNewKernel).stubs().will(returnValue(RT_ERROR_INVALID_VALUE));
    error = prog.UnifiedOneKernelRegister(&kernel);
    EXPECT_EQ(error, RT_ERROR_INVALID_VALUE);
    GlobalMockObject::verify();

    kernel.funcEntryType = KernelFunctionEntryType::KERNEL_TYPE_NOT_SUPPORT_FUNCTION_ENTRY;
    error = prog.UnifiedOneKernelRegister(&kernel);
    MOCKER_CPP(&ElfProgram::MixKernelAdd).stubs().will(returnValue(RT_ERROR_NONE));
    EXPECT_EQ(error, RT_ERROR_NONE);
    GlobalMockObject::verify();
}